# Because sharedstructures is a fully-compiled module and has no wrapper Python
# code, we define the type annotations separately in thie file.

__doc__ = "sharedstructures: dynamically-sized shared-memory data structures."

# TODO: Figure out how to make most of these classes (everything except
# IntVector) generic. The problem is that doing so without implementing
# __class_getitem__ causes problems when the specialized class is used in a
# type annotation.

from typing import Any, Generic, TypeVar

T = TypeVar("T")

# Note: This class doesn't really exist - C extensions are able to detect the
# situation where an argument wasn't passed at all, which is different from the
# situation where a kwarg takes on its default value because the caller didn't
# provide a value. In pure Python, however, this isn't possible, so we simulate
# it in the type annotations with this class.
class Missing:
    pass

MISSING = Missing()

def delete_pool(pool_name: str) -> bool: ...

class HashTableIterator(Generic[T]):
    # Has __new__, but should only be constructed internally
    def __repr__(self) -> str: ...
    def __iter__(self) -> "HashTableIterator[T]": ...
    def __next__(self) -> T: ...

class HashTable:
    def __init__(
        self,
        pool_name: str,
        allocator_type: str = "simple",
        base_offset: int = 0,
        bits: int = 8,
    ): ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def __contains__(self, key: bytes) -> bool: ...
    def __getitem__(self, key: bytes) -> Any: ...
    def __setitem__(self, key: bytes, o: Any) -> None: ...
    def __delitem__(self, key: bytes) -> None: ...
    def __iter__(self) -> HashTableIterator[bytes]: ...
    def pool_bytes(self) -> int: ...
    def pool_free_bytes(self) -> int: ...
    def pool_allocated_bytes(self) -> int: ...
    def check_and_set(
        self,
        check_key: bytes,
        check_value: Any,
        target_key: bytes,
        target_value: Any | Missing = MISSING,
    ) -> bool: ...
    def check_missing_and_set(
        self, check_key: bytes, target_key: bytes, target_value: Any | Missing = MISSING
    ) -> bool: ...
    def clear(self) -> None: ...
    def bits(self) -> int: ...
    def keys(self) -> HashTableIterator[bytes]: ...
    def values(self) -> HashTableIterator[Any]: ...
    def items(self) -> HashTableIterator[tuple[bytes, Any]]: ...
    def verify(self) -> bytes | None: ...

class PrefixTreeIterator(Generic[T]):
    # Has __new__, but should only be constructed internally
    def __repr__(self) -> str: ...
    def __iter__(self) -> "PrefixTreeIterator[T]": ...
    def __next__(self) -> T: ...

class PrefixTree:
    def __init__(
        self, pool_name: str, allocator_type: str = "simple", base_offset: int = 0
    ): ...
    def verify(self) -> bytes | None: ...
    def __len__(self) -> int: ...
    def __contains__(self, key: bytes) -> bool: ...
    def __getitem__(self, key: bytes) -> Any: ...
    def __setitem__(self, key: bytes, o: Any) -> None: ...
    def __delitem__(self, key: bytes) -> None: ...
    def __repr__(self) -> str: ...
    def clear(self) -> None: ...
    def incr(self, key: bytes, delta: int | float) -> int | float: ...
    def check_and_set(
        self,
        check_key: bytes,
        check_value: Any,
        target_key: bytes,
        target_value: Any | Missing = MISSING,
    ) -> bool: ...
    def check_missing_and_set(
        self, check_key: bytes, target_key: bytes, target_value: Any | Missing = MISSING
    ) -> bool: ...
    def keys(self) -> PrefixTreeIterator[bytes]: ...
    def keys_from(self, prefix: bytes) -> PrefixTreeIterator[bytes]: ...
    def values(self) -> PrefixTreeIterator[Any]: ...
    def values_from(self, prefix: bytes) -> PrefixTreeIterator[Any]: ...
    def items(self) -> PrefixTreeIterator[tuple[bytes, Any]]: ...
    def items_from(self, prefix: bytes) -> PrefixTreeIterator[tuple[bytes, Any]]: ...
    def __iter__(self) -> PrefixTreeIterator[bytes]: ...
    def bytes_for_prefix(self, prefix: bytes) -> int: ...
    def nodes_for_prefix(self, prefix: bytes) -> int: ...
    def pool_bytes(self) -> int: ...
    def pool_free_bytes(self) -> int: ...
    def pool_allocated_bytes(self) -> int: ...

class Queue:
    def __init__(
        self, pool_name: str, allocator_type: str = "simple", base_offset: int = 0
    ): ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def pop_front(self, raw: bool = False) -> Any: ...
    def pop_back(self, raw: bool = False) -> Any: ...
    def push_front(self, data: Any, raw: bool = False) -> None: ...
    def push_back(self, data: Any, raw: bool = False) -> None: ...
    def bytes(self) -> int: ...
    def pool_bytes(self) -> int: ...
    def pool_free_bytes(self) -> int: ...
    def pool_allocated_bytes(self) -> int: ...

class PriorityQueue:
    def __init__(
        self, pool_name: str, allocator_type: str = "simple", base_offset: int = 0
    ): ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def pop(self) -> Any: ...
    def push(self, item: Any) -> None: ...
    def pool_bytes(self) -> int: ...
    def pool_free_bytes(self) -> int: ...
    def pool_allocated_bytes(self) -> int: ...

class IntVector:
    def __init__(self, pool_name: str): ...
    def __repr__(self) -> str: ...
    def __len__(self) -> int: ...
    def expand(self, new_size: int) -> None: ...
    def load(self, index: int) -> int: ...
    def store(self, index: int, value: int) -> None: ...
    def exchange(self, index: int, value: int) -> int: ...
    def compare_exchange(
        self, index: int, expected_value: int, new_value: int
    ) -> int: ...
    def add(self, index: int, delta: int) -> int: ...
    def subtract(self, index: int, delta: int) -> int: ...
    def bitwise_and(self, index: int, mask: int) -> int: ...
    def bitwise_or(self, index: int, mask: int) -> int: ...
    def bitwise_xor(self, index: int, mask: int) -> int: ...
    def load_bit(self, bit_index: int) -> bool: ...
    def set_bit(self, bit_index: int, value: bool) -> None: ...
    def toggle_bit(self, bit_index: int) -> bool: ...
    def pool_bytes(self) -> int: ...
